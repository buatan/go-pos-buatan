// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: transaction.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const createPayment = `-- name: createPayment :one
insert into payments (transaction_id, company_id, code, date, amount, note, created_at)
values ($1, $2, $3, $4, $5, $6, $7)
returning id, transaction_id, company_id, code, date, amount, note, created_at, updated_at
`

type createPaymentParams struct {
	TransactionID sql.NullInt64  `json:"transaction_id"`
	CompanyID     int64          `json:"company_id"`
	Code          string         `json:"code"`
	Date          time.Time      `json:"date"`
	Amount        string         `json:"amount"`
	Note          sql.NullString `json:"note"`
	CreatedAt     time.Time      `json:"created_at"`
}

func (q *Queries) createPayment(ctx context.Context, arg createPaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, createPayment,
		arg.TransactionID,
		arg.CompanyID,
		arg.Code,
		arg.Date,
		arg.Amount,
		arg.Note,
		arg.CreatedAt,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.CompanyID,
		&i.Code,
		&i.Date,
		&i.Amount,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTransaction = `-- name: createTransaction :one
insert into transactions (code, date, subtotal, discount, note, contact_id, company_id, transaction_type, created_at)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9)
returning id, code, date, subtotal, discount, note, contact_id, company_id, transaction_type, created_at, updated_at
`

type createTransactionParams struct {
	Code            string         `json:"code"`
	Date            time.Time      `json:"date"`
	Subtotal        string         `json:"subtotal"`
	Discount        sql.NullString `json:"discount"`
	Note            sql.NullString `json:"note"`
	ContactID       int64          `json:"contact_id"`
	CompanyID       int64          `json:"company_id"`
	TransactionType string         `json:"transaction_type"`
	CreatedAt       time.Time      `json:"created_at"`
}

func (q *Queries) createTransaction(ctx context.Context, arg createTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.Code,
		arg.Date,
		arg.Subtotal,
		arg.Discount,
		arg.Note,
		arg.ContactID,
		arg.CompanyID,
		arg.TransactionType,
		arg.CreatedAt,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Date,
		&i.Subtotal,
		&i.Discount,
		&i.Note,
		&i.ContactID,
		&i.CompanyID,
		&i.TransactionType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTransactionItem = `-- name: createTransactionItem :one
insert into transaction_items (transaction_id, product_id, product_name, quantity, price, discount, note)
values ($1, $2, $3, $4, $5, $6, $7)
returning id, transaction_id, product_id, product_name, quantity, price, discount, note
`

type createTransactionItemParams struct {
	TransactionID int64          `json:"transaction_id"`
	ProductID     sql.NullInt64  `json:"product_id"`
	ProductName   string         `json:"product_name"`
	Quantity      string         `json:"quantity"`
	Price         string         `json:"price"`
	Discount      sql.NullString `json:"discount"`
	Note          sql.NullString `json:"note"`
}

func (q *Queries) createTransactionItem(ctx context.Context, arg createTransactionItemParams) (TransactionItem, error) {
	row := q.db.QueryRowContext(ctx, createTransactionItem,
		arg.TransactionID,
		arg.ProductID,
		arg.ProductName,
		arg.Quantity,
		arg.Price,
		arg.Discount,
		arg.Note,
	)
	var i TransactionItem
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.ProductID,
		&i.ProductName,
		&i.Quantity,
		&i.Price,
		&i.Discount,
		&i.Note,
	)
	return i, err
}

const getPayment = `-- name: getPayment :one
select id, transaction_id, company_id, code, date, amount, note, created_at, updated_at
from payments
where id = $1
  and company_id = $2
`

type getPaymentParams struct {
	ID        int64 `json:"id"`
	CompanyID int64 `json:"company_id"`
}

func (q *Queries) getPayment(ctx context.Context, arg getPaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, getPayment, arg.ID, arg.CompanyID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.CompanyID,
		&i.Code,
		&i.Date,
		&i.Amount,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPayments = `-- name: getPayments :many
select id, transaction_id, company_id, code, date, amount, note, created_at, updated_at
from payments
where company_id = $1
`

func (q *Queries) getPayments(ctx context.Context, companyID int64) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, getPayments, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.CompanyID,
			&i.Code,
			&i.Date,
			&i.Amount,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransaction = `-- name: getTransaction :one
select t.id, t.code, t.date, t.subtotal, t.discount, t.note, t.contact_id, t.company_id, t.transaction_type, t.created_at, t.updated_at,
       json_agg(ti.*) as items,
       json_agg(p.*)  as payments
from transactions t
left join transaction_items ti on t.id = ti.transaction_id
left join payments p on t.id = p.transaction_id
where t.id = $1
  and t.company_id = $2
group by 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
`

type getTransactionParams struct {
	ID        int64 `json:"id"`
	CompanyID int64 `json:"company_id"`
}

type getTransactionRow struct {
	ID              int64           `json:"id"`
	Code            string          `json:"code"`
	Date            time.Time       `json:"date"`
	Subtotal        string          `json:"subtotal"`
	Discount        sql.NullString  `json:"discount"`
	Note            sql.NullString  `json:"note"`
	ContactID       int64           `json:"contact_id"`
	CompanyID       int64           `json:"company_id"`
	TransactionType string          `json:"transaction_type"`
	CreatedAt       time.Time       `json:"created_at"`
	UpdatedAt       sql.NullTime    `json:"updated_at"`
	Items           json.RawMessage `json:"items"`
	Payments        json.RawMessage `json:"payments"`
}

func (q *Queries) getTransaction(ctx context.Context, arg getTransactionParams) (getTransactionRow, error) {
	row := q.db.QueryRowContext(ctx, getTransaction, arg.ID, arg.CompanyID)
	var i getTransactionRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Date,
		&i.Subtotal,
		&i.Discount,
		&i.Note,
		&i.ContactID,
		&i.CompanyID,
		&i.TransactionType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Items,
		&i.Payments,
	)
	return i, err
}

const getTransactions = `-- name: getTransactions :many
select id, code, date, subtotal, discount, note, contact_id, company_id, transaction_type, created_at, updated_at
from transactions
where company_id = $1
  and (contact_id = $2 or $2 isnull)
  and (transaction_type = $3 or $3 isnull)
order by date desc
`

type getTransactionsParams struct {
	CompanyID       int64          `json:"company_id"`
	ContactID       sql.NullInt64  `json:"contact_id"`
	TransactionType sql.NullString `json:"transaction_type"`
}

func (q *Queries) getTransactions(ctx context.Context, arg getTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactions, arg.CompanyID, arg.ContactID, arg.TransactionType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Date,
			&i.Subtotal,
			&i.Discount,
			&i.Note,
			&i.ContactID,
			&i.CompanyID,
			&i.TransactionType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
