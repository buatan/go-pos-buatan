// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: user.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countUsers = `-- name: countUsers :one
select count(*) as total
from up_users
where (provider = $1 or $1 isnull)
  and (confirmed = $2 or $2 isnull)
  and (blocked = $3 or $3 isnull)
  and deleted_at  is not null
`

type countUsersParams struct {
	Provider  sql.NullString `json:"provider"`
	Confirmed sql.NullBool   `json:"confirmed"`
	Blocked   sql.NullBool   `json:"blocked"`
}

func (q *Queries) countUsers(ctx context.Context, arg countUsersParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUsers, arg.Provider, arg.Confirmed, arg.Blocked)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createUser = `-- name: createUser :one
insert into up_users (username,
                      email,
                      provider,
                      password,
                      reset_password_token,
                      confirmation_token,
                      confirmed,
                      blocked,
                      name,
                      created_at)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
returning id, name, username, email, provider, password, reset_password_token, confirmation_token, confirmed, blocked, created_at, updated_at, deleted_at
`

type createUserParams struct {
	Username           string         `json:"username"`
	Email              string         `json:"email"`
	Provider           string         `json:"provider"`
	Password           string         `json:"password"`
	ResetPasswordToken sql.NullString `json:"reset_password_token"`
	ConfirmationToken  string         `json:"confirmation_token"`
	Confirmed          bool           `json:"confirmed"`
	Blocked            bool           `json:"blocked"`
	Name               sql.NullString `json:"name"`
	CreatedAt          time.Time      `json:"created_at"`
}

func (q *Queries) createUser(ctx context.Context, arg createUserParams) (UpUser, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Username,
		arg.Email,
		arg.Provider,
		arg.Password,
		arg.ResetPasswordToken,
		arg.ConfirmationToken,
		arg.Confirmed,
		arg.Blocked,
		arg.Name,
		arg.CreatedAt,
	)
	var i UpUser
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.Email,
		&i.Provider,
		&i.Password,
		&i.ResetPasswordToken,
		&i.ConfirmationToken,
		&i.Confirmed,
		&i.Blocked,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteUser = `-- name: deleteUser :one
update up_users
set deleted_at = now()
where id = $1
  and deleted_at  is not null
returning id
`

func (q *Queries) deleteUser(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, deleteUser, id)
	err := row.Scan(&id)
	return id, err
}

const getUser = `-- name: getUser :one
select id, name, username, email, provider, password, reset_password_token, confirmation_token, confirmed, blocked, created_at, updated_at, deleted_at
from up_users
where id = $1
  and deleted_at is not null
limit 1
`

func (q *Queries) getUser(ctx context.Context, id int64) (UpUser, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i UpUser
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.Email,
		&i.Provider,
		&i.Password,
		&i.ResetPasswordToken,
		&i.ConfirmationToken,
		&i.Confirmed,
		&i.Blocked,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUsers = `-- name: getUsers :many
select id, name, username, email, provider, password, reset_password_token, confirmation_token, confirmed, blocked, created_at, updated_at, deleted_at
from up_users
where (provider = $3 or $3 isnull)
  and (confirmed = $4 or $4 isnull)
  and (blocked = $5 or $5 isnull)
  and deleted_at  is not null
order by id desc
limit $1 offset $2
`

type getUsersParams struct {
	Limit     int32          `json:"limit"`
	Offset    int32          `json:"offset"`
	Provider  sql.NullString `json:"provider"`
	Confirmed sql.NullBool   `json:"confirmed"`
	Blocked   sql.NullBool   `json:"blocked"`
}

func (q *Queries) getUsers(ctx context.Context, arg getUsersParams) ([]UpUser, error) {
	rows, err := q.db.QueryContext(ctx, getUsers,
		arg.Limit,
		arg.Offset,
		arg.Provider,
		arg.Confirmed,
		arg.Blocked,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UpUser
	for rows.Next() {
		var i UpUser
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Username,
			&i.Email,
			&i.Provider,
			&i.Password,
			&i.ResetPasswordToken,
			&i.ConfirmationToken,
			&i.Confirmed,
			&i.Blocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: updateUser :one
update up_users
set email                = coalesce($2, email),
    password             = coalesce($3, password),
    reset_password_token = coalesce($4, reset_password_token),
    confirmed            = coalesce($5, confirmed),
    blocked              = coalesce($6, blocked),
    name                 = coalesce($7, name),
    updated_at           = $8
where id = $1
  and deleted_at  is not null
returning id, name, username, email, provider, password, reset_password_token, confirmation_token, confirmed, blocked, created_at, updated_at, deleted_at
`

type updateUserParams struct {
	ID                 int64          `json:"id"`
	Email              sql.NullString `json:"email"`
	Password           sql.NullString `json:"password"`
	ResetPasswordToken sql.NullString `json:"reset_password_token"`
	Confirmed          sql.NullBool   `json:"confirmed"`
	Blocked            sql.NullBool   `json:"blocked"`
	Name               sql.NullString `json:"name"`
	UpdatedAt          sql.NullTime   `json:"updated_at"`
}

func (q *Queries) updateUser(ctx context.Context, arg updateUserParams) (UpUser, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.ID,
		arg.Email,
		arg.Password,
		arg.ResetPasswordToken,
		arg.Confirmed,
		arg.Blocked,
		arg.Name,
		arg.UpdatedAt,
	)
	var i UpUser
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.Email,
		&i.Provider,
		&i.Password,
		&i.ResetPasswordToken,
		&i.ConfirmationToken,
		&i.Confirmed,
		&i.Blocked,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
